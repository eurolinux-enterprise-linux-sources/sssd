From 2d350235bc960a91233d29b97c3a205bd2e04c08 Mon Sep 17 00:00:00 2001
From: Sumit Bose <sbose@redhat.com>
Date: Fri, 8 Jun 2018 18:42:28 +0200
Subject: [PATCH] data provider: run offline callbacks only once

Reviewed-by: Jakub Hrozek <jhrozek@redhat.com>
(cherry picked from commit f28d995719db632130e9e063cb1ab7cb4e0fc8d8)
---
 src/providers/backend.h                 |  1 +
 src/providers/data_provider_be.c        |  1 +
 src/providers/data_provider_callbacks.c | 36 +++++++++++++++++++------
 3 files changed, 30 insertions(+), 8 deletions(-)

diff --git a/src/providers/backend.h b/src/providers/backend.h
index 1914274037ce7f7ff4b6d8486b041789a865fd59..6a34b91a911fc12163fa9448ea82ff93f5bf3849 100644
--- a/src/providers/backend.h
+++ b/src/providers/backend.h
@@ -95,6 +95,7 @@ struct be_ctx {
     struct be_cb *online_cb_list;
     bool run_online_cb;
     struct be_cb *offline_cb_list;
+    bool run_offline_cb;
     struct be_cb *reconnect_cb_list;
     /* In contrast to online_cb_list which are only run if the backend is
      * offline the unconditional_online_cb_list should be run whenever the
diff --git a/src/providers/data_provider_be.c b/src/providers/data_provider_be.c
index e8cddd976bb164dc6d4655bf2ebe9a03c3d9d26a..fad6f280195b615d1de45afaf0c459bdf78c8c0a 100644
--- a/src/providers/data_provider_be.c
+++ b/src/providers/data_provider_be.c
@@ -219,6 +219,7 @@ static void be_reset_offline(struct be_ctx *ctx)
 {
     ctx->offstat.went_offline = 0;
     ctx->offstat.offline = false;
+    ctx->run_offline_cb = true;
 
     reactivate_subdoms(ctx->domain);
 
diff --git a/src/providers/data_provider_callbacks.c b/src/providers/data_provider_callbacks.c
index 436357e228c0e1a689aa18b8ef41a82f63774d3a..24e125ea5be70208d7cf2cb06a80c39207e29db4 100644
--- a/src/providers/data_provider_callbacks.c
+++ b/src/providers/data_provider_callbacks.c
@@ -265,22 +265,42 @@ void be_run_unconditional_online_cb(struct be_ctx *be)
 int be_add_offline_cb(TALLOC_CTX *mem_ctx, struct be_ctx *ctx, be_callback_t cb,
                       void *pvt, struct be_cb **offline_cb)
 {
-    return be_add_cb(mem_ctx, ctx, cb, pvt, &ctx->offline_cb_list, offline_cb);
+    int ret;
+
+    ret = be_add_cb(mem_ctx, ctx, cb, pvt, &ctx->offline_cb_list, offline_cb);
+    if (ret != EOK) {
+        DEBUG(SSSDBG_CRIT_FAILURE, "be_add_cb failed.\n");
+        return ret;
+    }
+
+    /* Make sure we run the callback when SSSD goes offline */
+    ctx->run_offline_cb = true;
+
+    return EOK;
 }
 
 void be_run_offline_cb(struct be_ctx *be) {
     int ret;
 
-    if (be->offline_cb_list) {
-        DEBUG(SSSDBG_MINOR_FAILURE, "Going offline. Running callbacks.\n");
+    if (be->run_offline_cb) {
+        /* Reset the flag, we only want to run these callbacks once when going
+         * offline */
+        be->run_offline_cb = false;
 
-        ret = be_run_cb(be, be->offline_cb_list);
-        if (ret != EOK) {
-            DEBUG(SSSDBG_CRIT_FAILURE, "be_run_cb failed.\n");
+        if (be->offline_cb_list) {
+            DEBUG(SSSDBG_MINOR_FAILURE, "Going offline. Running callbacks.\n");
+
+            ret = be_run_cb(be, be->offline_cb_list);
+            if (ret != EOK) {
+                DEBUG(SSSDBG_CRIT_FAILURE, "be_run_cb failed.\n");
+            }
+
+        } else {
+            DEBUG(SSSDBG_TRACE_ALL,
+                  "Offline call back list is empty, nothing to do.\n");
         }
-
     } else {
         DEBUG(SSSDBG_TRACE_ALL,
-              "Offline call back list is empty, nothing to do.\n");
+              "Flag indicates that offline callback were already called.\n");
     }
 }
-- 
2.17.1

